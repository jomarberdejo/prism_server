import admin from "firebase-admin";
import { ppaRepository } from "@/data/ppa";
import { formatDate, formatTime } from "@/utils/dates";

var serviceAccount = require("../../service-account.json");

if (!admin.apps.length) {
  try {
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
    console.log("‚úÖ Firebase Admin initialized");
  } catch (error) {
    console.error("‚ùå Firebase Admin initialization error:", error);
  }
}

const sentReminders = new Set<string>();

function detectPlatform(pushToken: string): "fcm" | "apns" | null {
  if (!pushToken) return null;
  if (/^[0-9a-f]{64}$/i.test(pushToken)) return "apns";
  return "fcm";
}

async function sendFCMNotification({ fcmToken, title, body, data = {} }: { fcmToken: string; title: string; body: string; data?: Record<string, string>; }) {
  const message = {
    token: fcmToken,
    notification: { title, body },
    data,
    android: { priority: "high" as const, notification: { channelId: "default", sound: "default", priority: "high" as const } },
  };

  try {
    const response = await admin.messaging().send(message);
    console.log("‚úÖ FCM notification sent:", response);
    return true;
  } catch (error) {
    console.error("‚ùå Error sending FCM notification:", error);
    return false;
  }
}

async function sendAPNsNotification({ apnsToken, title, body, data = {} }: { apnsToken: string; title: string; body: string; data?: Record<string, string>; }) {
  const message = {
    token: apnsToken,
    notification: { title, body },
    data,
    apns: { payload: { aps: { alert: { title, body }, sound: "default", badge: 1 } } },
  };

  try {
    const response = await admin.messaging().send(message);
    console.log("‚úÖ APNs notification sent:", response);
    return true;
  } catch (error) {
    console.error("‚ùå Error sending APNs notification:", error);
    return false;
  }
}

async function sendPushNotification({ ppaId, pushToken, title, body, notificationType }: { ppaId: string; pushToken: string; title: string; body: string; notificationType: "day_before" | "hour_before"; }) {
  if (!pushToken) return false;

  const platform = detectPlatform(pushToken);
  if (!platform) return false;

  const data = { ppaId, notificationType };
  let success = false;

  try {
    if (platform === "fcm") {
      success = await sendFCMNotification({ fcmToken: pushToken, title, body, data });
    } else {
      success = await sendAPNsNotification({ apnsToken: pushToken, title, body, data });
    }

    if (success) {
      const updateField = notificationType === "day_before" ? { dayBeforeNotifiedAt: new Date() } : { hourBeforeNotifiedAt: new Date() };
      await ppaRepository.update(ppaId, updateField);
    }

    return success;
  } catch (error) {
    console.error("‚ùå Error sending push notification:", error);
    return false;
  }
}

/**
 * Run all reminders for all PPAs immediately
 */
export async function runAllReminders() {
  console.log("‚è∞ Running all reminders...");

  const allPPAs = await ppaRepository.findAll();

  for (const ppa of allPPAs) {
    const reminderTypes: ("day_before" | "hour_before")[] = ["day_before", "hour_before"];

    for (const type of reminderTypes) {
      const reminderKey = `${ppa.id}-${type}`;
      if (sentReminders.has(reminderKey)) continue;

      const userPushToken = ppa.user?.pushToken;
      if (!userPushToken) {
        console.warn(`‚ö†Ô∏è Skipping ${type} reminder for PPA "${ppa.task}" - no push token found`);
        continue;
      }

      const title = type === "day_before" ? `üìÖ Reminder: ${ppa.task}` : `‚è∞ Starting Soon: ${ppa.task}`;
      const body = type === "day_before"
        ? `Event starts at ${formatTime(ppa.startDate)} and ends on ${formatDate(ppa.dueDate)} at ${formatTime(ppa.dueTime)}.`
        : `Your event starts soon at ${formatTime(ppa.startTime)}. Location: ${ppa.venue || ppa.address}`;

      try {
        const success = await sendPushNotification({
          ppaId: ppa.id,
          pushToken: userPushToken,
          title,
          body,
          notificationType: type,
        });

        if (success) {
          sentReminders.add(reminderKey);
          console.log(`‚úÖ Success: ${type} reminder sent for PPA "${ppa.task}" to token: ${userPushToken.substring(0, 20)}...`);
        } else {
          console.error(`‚ùå Failed: ${type} reminder NOT sent for PPA "${ppa.task}" to token: ${userPushToken.substring(0, 20)}...`);
        }
      } catch (error) {
        console.error(`‚ùå Error sending ${type} reminder for PPA "${ppa.task}"`, error);
      }
    }
  }

  console.log("‚è∞ All reminders processed");
}


/**
 * Reschedule notification (call directly)
 */
export async function remindReschedulePPA({ ppaId, pushToken, title, body }: { ppaId: string; pushToken: string; title: string; body: string; }) {
  const success = await sendPushNotification({
    ppaId,
    pushToken,
    title,
    body,
    notificationType: "day_before",
  });

  console.log("üì¨ RESCHEDULE NOTIFICATION SENT:", success);
  return success;
}
